=========
DataJoint
=========

Why Should You Use DataJoint?
-----------------------------
Datajoint is a python package created by Vathes to allow eaiser access and data pipeline creation without directly interfacing with a SQL Database which would require learning SQL commands as well as how to use the connector to send those queries to the database.

For example, let say we want to join two tables name table_1 and table_2 and get all the data from it:

In (SQL) this is the query we have to write which then get fed through connector package:

.. code-block:: SQL
    :linenos:

    SELECT *
    FROM table_1
    INNER JOIN table_2 ON join_condition;

On the other hand with DataJoint (python) all we need to do is write this line:

.. code-block:: python
    :linenos:

    (table_1 * table_2).fetch()

Installing DataJoint
--------------------

Datajoint can be installed via pip3 or via Anaconda

pip3:

.. code-block:: python
    :linenos:

    pip3 install datajoint

Anaconda:

.. code-block:: python
    :linenos:

    conda install -c conda-forge datajoint

Setting Up Login Credentials
----------------------------

To get your datajoint login, please contact Daniel Sitonic on Slack, he will be able to create your database credential.
Datajoint will then use those credentials to login into the database and allow you to use it.

This is the basic setup of the login information for datajoint. This only needs to be run once per computer.
In Docker this is done by setting the enviorment variables which datajoint will use (more details on K8 stuff)

pip3:

.. code-block:: python
    :linenos:

    import datajoint as dj

    dj.config['database.host'] = 'at-database1.ad.bcm.edu' # This the database server, yes you must VPN into Baylor
    dj.config['database.username'] = 'yourusername' # Provided when you setup an account with Daniel
    dj.config['database.password'] = 'NotMyRealPassword' # Provided when you setup an account with Daniel

    dj.config.save_global() # Save the information above on your machine so you don't have to do this again.

Overview of the Basics of DataJoint
-----------------------------------

DataJoint has several table classes that serves as the bases for all tables the user will need:

- dj.Manual
- dj.Computed
- dj.Lookup
- dj.Imported
- dj.Part

We will mostly only focus on the dj.Manual, dj.Computed, and dj.Lookup

Schema
------

Each table in the database belongs to something call a schema which is a logical representation of database. In short each schema has a collection of
tables which can only be access via that schema.

In datajoint, to select what schema the table should be place under, datajoint uses class decarators:

.. code-block:: python
    :linenos:

    import datajoint as dj

    schema = dj.schema('synicix_datajoint_tutorial') # This is how you set the schema

    # Example Manual table, more detail explinations on the following sections
    @schema
    class Student(dj.Manual):
        definition = """
        student_id : int unsigned
        ---
        first_name : varchar(64)
        last_name : varchar(64)
        """

**NOTE: By default the user are only given permission to create and access schemas with user_*, all other schemas access permission must go through Daniel**

Table Definition
------------------------------

For each table define in datajoint, there are a set of primary and non-primary attributes (columns) that is use to define what is contain inside of the table where primary 
attributes are what uniquely identify each tuple.

In datajoint table, each class has a field call definition, which define the primary and non-primary attributes of the table as well as its datatype.
Every attributes that is define above "- - -" (line 10) is consider to be primary, while everything below is not.

Each attributes the attribute name on the left followed by ":" then the datatype of the attribute.
Details on the datatypes can be found in the next section.

.. code-block:: python
    :linenos:

    import datajoint as dj

    schema = dj.schema('synicix_datajoint_tutorial') # This is how you set the schema

    # Example Manual table, more detail explinations on the following sections
    @schema
    class Student(dj.Manual):
        definition = """
        student_id : int unsigned
        ---
        first_name : varchar(64)
        last_name : varchar(64)
        """


One important note about primary attributes are index, meaning any restrictions are join done on those attributes are vastly faster then on non-primary attributes

Also for tips in designing primary attributes, if the table have a lot of primary key attributes, it will probably be better to do an MD5 hash in those cases, but this varies.


Datatypes
---------
These are the datatype that datajoint supports:

- **tinyint:** an 8-bit integer number, ranging from -128 to 127.
- **tinyint unsigned:** an 8-bit positive integer number, ranging from 0 to 255.
- **smallint:** a 16-bit integer number, ranging from -32,768 to 32,767.
- **smallint unsigned:** a 16-bit positive integer, ranging from 0 to 65,535.
- **int:** a 32-bit integer number, ranging from -2,147,483,648 to 2,147,483,647.
- **int unsigned:** a 32-bit positive integer, ranging from 0 to 4,294,967,295.
- **enum:** one of several explicitly enumerated values specified as strings. Use this datatype instead of text strings to avoid spelling variations and to save storage space. For example, for anesthesia, the datatype could be enum("urethane", "isoflurane", "fentanyl"). Do not use enums in primary keys due to the difficulty of changing their definitions consistently in multiple tables.
- **date:** date as 'YYYY-MM-DD'.
- **time:** time as 'HH:MM:SS'.
- **timestamp:** Date and time to the second as 'YYYY-MM-DD HH:MM:SS'. The default value may be set to CURRENT_TIMESTAMP.
- **char(N):** a character string up to N characters (but always takes the entire N bytes to store).
- **varchar(N):** a text string of arbitrary length up to N characters that takes N+1 or N+2 bytes of storage.
- **float:** a single-precision floating-point number. Takes 4 bytes. Single precision is sufficient for many measurements.
- **double:** a double-precision floating-point number. Takes 8 bytes. Because equality comparisons are error-prone, neither float nor double should be used in primary keys.
- **decimal(N,F):** a fixed-point number with N total decimal digits and F fractional digits. This datatype is well suited to represent numbers whose magnitude is well defined and does not warrant the use of floating-point representation or requires precise decimal representations (e.g. dollars and cents). Because of its well-defined precision, decimal values can be used in equality comparison and be included in primary keys.
- **longblob:** arbitrary MATLAB value (e.g. matrix, image, structure), up to 4 GiB in size. In Python, arbitrary numeric numpy array. Numeric arrays are compatible between MATLAB and Python.
- **decimal(N,F) unsigned:** same as decimal, but limited to nonnegative values.
- **mediumint:** a 24-bit integer number, ranging from -8,388,608 to 8,388,607.
- **mediumint unsigned:** a 24-bit positive integer, ranging from 0 to 16,777,216.


External Storage
----------------


dj.Manual
---------

In datajoint, for each 

dj.Computed
-----------

dj.Lookup
---------
    

Other Resources:
----------------
| DataJoint Full Documentation: https://docs.datajoint.io/python/ \n
| GitHub: https://github.com/datajoint/datajoint-python



